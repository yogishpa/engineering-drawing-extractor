"""
Main Streamlit application for the Engineering Drawing Extractor.

This module provides the user interface for uploading PDFs, selecting extraction methods,
and displaying results with download functionality.
"""

import streamlit as st
import pandas as pd
import json
import io
import time
import hashlib
from datetime import datetime, timedelta
from typing import Optional, Dict, Any

from extractor import ExtractionEngine, PDFValidationError, create_extraction_engine
from models import ExtractionResult
from aws_clients import AWSClientError
from error_handler import (
    error_handler, handle_extraction_errors, display_system_health,
    highlight_low_confidence_results, display_processing_feedback,
    validate_file_upload as validate_file_upload_enhanced
)

# Configure Streamlit page
st.set_page_config(
    page_title="Engineering Drawing Extractor",
    page_icon="📐",
    layout="wide",
    initial_sidebar_state="expanded"
)


def create_csv_export(result: ExtractionResult) -> str:
    """Create CSV export of extraction results."""
    output = io.StringIO()
    
    # Write header information
    output.write(f"Engineering Drawing Extraction Results\n")
    output.write(f"File: {result.filename}\n")
    output.write(f"Method: {result.extraction_method}\n")
    output.write(f"Confidence: {result.overall_confidence:.1%}\n")
    output.write(f"Processing Time: {result.processing_time:.1f}s\n")
    output.write(f"Timestamp: {result.timestamp}\n\n")
    
    # Dimensions
    if result.dimensions:
        output.write("DIMENSIONS\n")
        output.write("Value,Unit,Type,Confidence,Location,Raw Text\n")
        for dim in result.dimensions:
            output.write(f"{dim.value},{dim.unit},{dim.type},{dim.confidence:.3f},"
                        f'"{dim.location_description}","{dim.raw_text}"\n')
        output.write("\n")
    
    # Tolerances
    if result.tolerances:
        output.write("TOLERANCES\n")
        output.write("Type,Value,Confidence,Associated Dimension,Raw Text\n")
        for tol in result.tolerances:
            output.write(f"{tol.type},{tol.value},{tol.confidence:.3f},"
                        f"{tol.associated_dimension_id or ''},"
                        f'"{tol.raw_text}"\n')
        output.write("\n")
    
    # Part Numbers
    if result.part_numbers:
        output.write("PART NUMBERS\n")
        output.write("Identifier,Description,Confidence,Raw Text\n")
        for part in result.part_numbers:
            output.write(f"{part.identifier},{part.description or ''},"
                        f"{part.confidence:.3f},"
                        f'"{part.raw_text}"\n')
        output.write("\n")
    
    # Annotations
    if result.annotations:
        output.write("ANNOTATIONS\n")
        output.write("Text,Type,Confidence,Location\n")
        for ann in result.annotations:
            output.write(f'"{ann.text}",{ann.type},{ann.confidence:.3f},'
                        f'"{ann.location_description}"\n')
    
    return output.getvalue()


def create_summary_report(result: ExtractionResult) -> str:
    """Create summary report of extraction results."""
    stats = result.get_summary_stats()
    
    report = f"""
ENGINEERING DRAWING EXTRACTION SUMMARY
=====================================

File Information:
- Filename: {result.filename}
- Processing Method: {result.extraction_method.replace('_', ' ').title()}
- Processing Time: {result.processing_time:.1f} seconds
- Overall Confidence: {result.overall_confidence:.1%}
- Extraction Date: {result.timestamp.strftime('%Y-%m-%d %H:%M:%S')}

Extraction Results:
- Dimensions Found: {stats['dimensions']}
- Tolerances Found: {stats['tolerances']}
- Part Numbers Found: {stats['part_numbers']}
- Annotations Found: {stats['annotations']}
- Total Items: {stats['total_items']}

Quality Assessment:
- High Confidence Items (≥80%): {len([item for item in (result.dimensions + result.tolerances + result.part_numbers + result.annotations) if item.confidence >= 0.8])}
- Medium Confidence Items (50-79%): {len([item for item in (result.dimensions + result.tolerances + result.part_numbers + result.annotations) if 0.5 <= item.confidence < 0.8])}
- Low Confidence Items (<50%): {len([item for item in (result.dimensions + result.tolerances + result.part_numbers + result.annotations) if item.confidence < 0.5])}

Processing Notes:
"""
    
    if result.errors:
        report += "- Warnings/Errors:\n"
        for error in result.errors:
            report += f"  • {error}\n"
    else:
        report += "- No processing errors or warnings\n"
    
    report += f"""
Recommendations:
- Review items with confidence below 80% for accuracy
- Verify dimensional measurements against original drawing
- Cross-check part numbers with design specifications
- Validate tolerance specifications for manufacturing requirements

Generated by Engineering Drawing Extractor
"""
    
    return report


def display_confidence_badge(confidence: float) -> str:
    """Create a colored confidence badge based on confidence level."""
    if confidence >= 0.8:
        return f"🟢 **{confidence:.1%}** (High)"
    elif confidence >= 0.5:
        return f"🟡 **{confidence:.1%}** (Medium)"
    else:
        return f"🔴 **{confidence:.1%}** (Low)"


def display_error_message(error_type: str, message: str, suggestions: list = None):
    """Display user-friendly error messages with suggestions."""
    st.error(f"**{error_type}**: {message}")
    
    if suggestions:
        st.info("**Suggestions:**")
        for suggestion in suggestions:
            st.write(f"• {suggestion}")


def validate_file_upload_legacy(uploaded_file) -> tuple[bool, str, list]:
    """
    Legacy file validation function (kept for compatibility).
    Use validate_file_upload_enhanced from error_handler instead.
    """
    if uploaded_file is None:
        return False, "No file uploaded", ["Please select a PDF file to upload"]
    
    # Check file size (100MB limit)
    max_size_mb = 100
    file_size_mb = len(uploaded_file.getvalue()) / (1024 * 1024)
    
    if file_size_mb > max_size_mb:
        return False, f"File size ({file_size_mb:.1f}MB) exceeds maximum allowed size ({max_size_mb}MB)", [
            "Try compressing the PDF file",
            "Split large drawings into multiple files",
            "Remove unnecessary pages or images from the PDF"
        ]
    
    # Check file extension
    if not uploaded_file.name.lower().endswith('.pdf'):
        return False, "Invalid file format", [
            "Only PDF files are supported",
            "Convert your file to PDF format",
            "Ensure the file extension is .pdf"
        ]
    
    # Check if file is empty
    if file_size_mb < 0.001:  # Less than 1KB
        return False, "File appears to be empty or corrupted", [
            "Try uploading the file again",
            "Check if the original file opens correctly",
            "Ensure the file is not corrupted"
        ]
    
    return True, "", []


def display_processing_status(status: str, progress: float = 0.0):
    """Display processing status with progress indicator."""
    status_messages = {
        'validating': '🔍 Validating PDF file...',
        'preprocessing': '⚙️ Preprocessing document...',
        'extracting_bda': '🤖 Extracting with Bedrock Data Automation...',
        'extracting_claude': '🧠 Analyzing with Claude 4 Sonnet...',
        'extracting_textract': '📄 Processing with Amazon Textract...',
        'parsing': '📊 Parsing extraction results...',
        'complete': '✅ Extraction completed successfully!',
        'error': '❌ Extraction failed'
    }
    
    message = status_messages.get(status, f"Processing: {status}")
    st.info(message)
    
    if 0 < progress < 1:
        st.progress(progress)


def display_extraction_results(result: ExtractionResult):
    """Display extraction results with confidence indicators and warnings."""
    # Overall summary
    # Debug information
    st.write("**Debug Info:**")
    st.write(f"- Dimensions: {len(result.dimensions)}")
    st.write(f"- Tolerances: {len(result.tolerances)}")
    st.write(f"- Part Numbers: {len(result.part_numbers)}")
    st.write(f"- Annotations: {len(result.annotations)}")
    if hasattr(result, 'raw_result') and result.raw_result:
        st.write(f"- Raw result: {str(result.raw_result)[:200]}...")
    
    # Overall summary    st.success(f"✅ Extraction completed in {result.processing_time:.1f}s using {result.extraction_method.replace('_', ' ').title()}")
    
    # Overall confidence
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Overall Confidence", display_confidence_badge(result.overall_confidence))
    with col2:
        st.metric("Total Items Found", result.get_total_items())
    with col3:
        st.metric("Processing Method", result.extraction_method.replace('_', ' ').title())
    
    # Use enhanced confidence highlighting
    highlight_low_confidence_results(result, confidence_threshold=0.7)
    
    # Display errors if any
    if result.errors:
        st.warning("⚠️ **Processing Warnings:**")
        for error in result.errors:
            st.write(f"• {error}")
    
    # Check if this is a barrel diagram first
    barrel_fields = ['Overall barrel length', 'Barrel head length', 'Port to shoulder length', 'Barrel head Dia', 'Barrel shaft Dia']
    is_barrel = any(dim.type in barrel_fields for dim in result.dimensions) if result.dimensions else False
    
    if is_barrel:
        # Show only barrel-specific measurements in table format
        st.subheader("📏 Barrel Measurements")
        
        # Create tabular data for barrel dimensions
        barrel_data = {}
        part_number = "Unknown"
        
        # Extract part number if available
        if result.part_numbers:
            part_number = result.part_numbers[0].identifier
        
        # Organize dimensions by type
        for dim in result.dimensions:
            if dim.type in barrel_fields:
                value_with_tolerance = f"{dim.value}"
                if dim.unit:
                    value_with_tolerance += f" {dim.unit}"
                barrel_data[dim.type] = value_with_tolerance
        
        # Create DataFrame for display
        import pandas as pd
        df_data = {
            'Part Number': [part_number],
            'Overall barrel length': [barrel_data.get('Overall barrel length', '')],
            'Barrel head length': [barrel_data.get('Barrel head length', '')],
            'Port to shoulder length': [barrel_data.get('Port to shoulder length', '')],
            'Barrel head Dia': [barrel_data.get('Barrel head Dia', '')],
            'Barrel shaft Dia': [barrel_data.get('Barrel shaft Dia', '')]
        }
        
        df = pd.DataFrame(df_data)
        st.dataframe(df, use_container_width=True)
        
        # Show download options for barrel data
        st.subheader("📥 Download Barrel Data")
        csv_data = df.to_csv(index=False)
        st.download_button(
            label="Download as CSV",
            data=csv_data,
            file_name=f"barrel_measurements_{part_number}.csv",
            mime="text/csv"
        )
        return  # Skip the standard tabbed display
    
    # Standard tabbed results display for non-barrel diagrams
    tab1, tab2, tab3, tab4, tab5 = st.tabs(["📊 Summary", "📏 Dimensions", "⚖️ Tolerances", "🏷️ Part Numbers", "📝 Annotations"])
    
    with tab1:
        stats = result.get_summary_stats()
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("Extraction Statistics")
            st.write(f"**Dimensions:** {stats['dimensions']}")
            st.write(f"**Tolerances:** {stats['tolerances']}")
            st.write(f"**Part Numbers:** {stats['part_numbers']}")
            st.write(f"**Annotations:** {stats['annotations']}")
        
        with col2:
            st.subheader("Quality Assessment")
            all_items = result.dimensions + result.tolerances + result.part_numbers + result.annotations
            if all_items:
                high_conf = len([item for item in all_items if item.confidence >= 0.8])
                med_conf = len([item for item in all_items if 0.5 <= item.confidence < 0.8])
                low_conf = len([item for item in all_items if item.confidence < 0.5])
                
                st.write(f"🟢 **High Confidence (≥80%):** {high_conf}")
                st.write(f"🟡 **Medium Confidence (50-79%):** {med_conf}")
                st.write(f"🔴 **Low Confidence (<50%):** {low_conf}")
    
    with tab2:
        if result.dimensions:
            # Check if this is a barrel diagram
            barrel_fields = ['Overall barrel length', 'Barrel head length', 'Port to shoulder length', 'Barrel head Dia', 'Barrel shaft Dia']
            is_barrel = any(dim.type in barrel_fields for dim in result.dimensions)
            
            if is_barrel:
                st.subheader("Barrel Diagram Measurements")
                
                # Create tabular data for barrel dimensions
                barrel_data = {}
                part_number = "Unknown"
                
                # Extract part number if available
                if result.part_numbers:
                    part_number = result.part_numbers[0].identifier
                
                # Organize dimensions by type
                for dim in result.dimensions:
                    if dim.type in barrel_fields:
                        value_with_tolerance = f"{dim.value}"
                        if dim.unit:
                            value_with_tolerance += f" {dim.unit}"
                        barrel_data[dim.type] = value_with_tolerance
                
                # Create DataFrame for display
                import pandas as pd
                df_data = {
                    'Part Number': [part_number],
                    'Overall barrel length': [barrel_data.get('Overall barrel length', '')],
                    'Barrel head length': [barrel_data.get('Barrel head length', '')],
                    'Port to shoulder length': [barrel_data.get('Port to shoulder length', '')],
                    'Barrel head Dia': [barrel_data.get('Barrel head Dia', '')],
                    'Barrel shaft Dia': [barrel_data.get('Barrel shaft Dia', '')]
                }
                
                df = pd.DataFrame(df_data)
                st.dataframe(df, use_container_width=True)
                return  # Skip standard display for barrel diagrams
            
            # Standard dimension display            for dim in result.dimensions:
                col1, col2, col3 = st.columns([2, 1, 1])
                with col1:
                    st.write(f"**{dim.value} {dim.unit}** ({dim.type})")
                    if dim.location_description:
                        st.caption(f"Location: {dim.location_description}")
                with col2:
                    st.write(display_confidence_badge(dim.confidence))
                with col3:
                    if dim.raw_text:
                        st.caption(f"Raw: {dim.raw_text}")
        else:
            st.info("No dimensions found in the document.")
    
    with tab3:
        if result.tolerances:
            for tol in result.tolerances:
                col1, col2, col3 = st.columns([2, 1, 1])
                with col1:
                    st.write(f"**{tol.value}** ({tol.type})")
                with col2:
                    st.write(display_confidence_badge(tol.confidence))
                with col3:
                    if tol.raw_text:
                        st.caption(f"Raw: {tol.raw_text}")
        else:
            st.info("No tolerances found in the document.")
    
    with tab4:
        if result.part_numbers:
            for part in result.part_numbers:
                col1, col2, col3 = st.columns([2, 1, 1])
                with col1:
                    st.write(f"**{part.identifier}**")
                    if part.description:
                        st.caption(f"Description: {part.description}")
                with col2:
                    st.write(display_confidence_badge(part.confidence))
                with col3:
                    if part.raw_text:
                        st.caption(f"Raw: {part.raw_text}")
        else:
            st.info("No part numbers found in the document.")
    
    with tab5:
        if result.annotations:
            for ann in result.annotations:
                col1, col2, col3 = st.columns([2, 1, 1])
                with col1:
                    st.write(f"**{ann.text}** ({ann.type})")
                    if ann.location_description:
                        st.caption(f"Location: {ann.location_description}")
                with col2:
                    st.write(display_confidence_badge(ann.confidence))
        else:
            st.info("No annotations found in the document.")


@st.cache_data(ttl=3600)  # Cache for 1 hour
def get_cached_extraction_result(file_hash: str, method: str, confidence_filter: bool):
    """Cache extraction results to avoid reprocessing the same file."""
    # This function will be called by the caching mechanism
    # The actual extraction will be done outside this function
    return None

def calculate_file_hash(file_content: bytes) -> str:
    """Calculate hash of file content for caching."""
    return hashlib.md5(file_content).hexdigest()

def initialize_session_state():
    """Initialize session state variables."""
    if 'extraction_history' not in st.session_state:
        st.session_state.extraction_history = []
    
    if 'current_result' not in st.session_state:
        st.session_state.current_result = None
    
    if 'processing_status' not in st.session_state:
        st.session_state.processing_status = None

def main():
    """Main application function."""
    st.title("📐 Engineering Drawing Extractor")
    st.markdown("Extract dimensions, tolerances, part numbers, and annotations from engineering drawings using AI")
    
    # Initialize session state
    initialize_session_state()
    
    # Sidebar configuration
    with st.sidebar:
        st.header("⚙️ Configuration")
        
        # Extraction method selection
        extraction_method = st.selectbox(
            "Extraction Method",
            ["auto", "claude_4_5_sonnet", "textract", "bedrock_data_automation"],
            help="Choose the AI service for extraction. 'Auto' tries methods in order of preference."
        )
        
        # Confidence filter
        confidence_filter = st.checkbox(
            "Filter Low Confidence Results",
            value=True,
            help="Remove results with confidence below 70%"
        )
        
        # AWS Region
        aws_region = st.selectbox(
            "AWS Region",
            ["us-east-1", "us-west-2", "eu-west-1", "ap-southeast-1"],
            help="AWS region for service calls"
        )
        
        # Display system health
        display_system_health()
        
        # Extraction history
        if st.session_state.extraction_history:
            st.subheader("📊 Recent Extractions")
            for i, extraction in enumerate(reversed(st.session_state.extraction_history[-5:])):  # Show last 5
                with st.expander(f"{extraction['filename']} ({extraction['method']})"):
                    st.write(f"**Time:** {extraction['timestamp'].strftime('%H:%M:%S')}")
                    st.write(f"**Items:** {extraction['total_items']}")
                    st.write(f"**Confidence:** {extraction['confidence']:.1%}")
        
        # Performance metrics
        if st.session_state.current_result:
            st.subheader("⚡ Performance")
            result = st.session_state.current_result
            st.metric("Processing Time", f"{result.processing_time:.1f}s")
            st.metric("Items/Second", f"{result.get_total_items() / max(result.processing_time, 0.1):.1f}")
        
        # Clear history button
        if st.session_state.extraction_history:
            if st.button("🗑️ Clear History"):
                st.session_state.extraction_history = []
                st.rerun()
    
    # File upload with validation
    st.subheader("📁 Upload Engineering Drawing")
    uploaded_file = st.file_uploader(
        "Choose a PDF file",
        type=['pdf'],
        help="Upload an engineering drawing in PDF format (max 100MB)"
    )
    
    if uploaded_file is not None:
        # Validate file using enhanced validation
        is_valid, error_msg = validate_file_upload_enhanced(uploaded_file, max_size_mb=100)
        
        if not is_valid:
            st.error(f"❌ **File Validation Error**: {error_msg}")
            return
        
        # Display file info
        file_size_mb = len(uploaded_file.getvalue()) / (1024 * 1024)
        st.success(f"✅ File uploaded: **{uploaded_file.name}** ({file_size_mb:.1f}MB)")
        
        # Extract button
        if st.button("🚀 Extract Data", type="primary"):
            try:
                # Calculate file hash for caching
                pdf_content = uploaded_file.getvalue()
                file_hash = calculate_file_hash(pdf_content)
                
                # Check if we have a cached result
                cache_key = f"{file_hash}_{extraction_method}_{confidence_filter}"
                cached_result = get_cached_extraction_result(file_hash, extraction_method, confidence_filter)
                
                if cached_result:
                    st.info("📋 Using cached result from previous extraction")
                    st.session_state.current_result = cached_result
                    from barrel_display import display_barrel_results
                    display_barrel_results(cached_result)
                    return
                
                # Initialize extraction engine
                with st.spinner("Initializing extraction engine..."):
                    engine = create_extraction_engine(aws_region=aws_region)
                
                # Check available methods
                available_methods = engine.get_available_methods()
                if not available_methods:
                    display_error_message(
                        "Service Unavailable",
                        "No extraction services are currently available",
                        [
                            "Check your AWS credentials configuration",
                            "Verify AWS services are available in your region",
                            "Try again in a few minutes"
                        ]
                    )
                    return
                
                # Validate selected method
                if extraction_method != "auto" and extraction_method not in available_methods:
                    display_error_message(
                        "Method Unavailable",
                        f"Selected method '{extraction_method}' is not available",
                        [f"Available methods: {', '.join(available_methods)}",
                         "Try selecting 'auto' for automatic method selection"]
                    )
                    return
                
                # Show processing status using enhanced feedback
                st.session_state.processing_status = 'starting'
                progress_bar = display_processing_feedback('starting', message="Initializing extraction process")
                
                # Update processing status
                st.session_state.processing_status = 'processing'
                display_processing_feedback('processing', progress=0.3, message=f"Extracting data using {extraction_method}")
                
                # Perform extraction
                result = engine.extract_from_pdf(
                    pdf_content=pdf_content,
                    filename=uploaded_file.name,
                    method=extraction_method,
                    confidence_filter=confidence_filter
                )
                
                # Store result in session state
                st.session_state.current_result = result
                st.session_state.processing_status = 'complete'
                
                # Add to extraction history
                st.session_state.extraction_history.append({
                    'filename': uploaded_file.name,
                    'method': extraction_method,
                    'timestamp': datetime.now(),
                    'total_items': result.get_total_items(),
                    'confidence': result.overall_confidence
                })
                
                # Show completion
                display_processing_feedback('complete', message=f"Found {result.get_total_items()} items with {result.overall_confidence:.1%} confidence")
                
                # Display results
                from barrel_display import display_barrel_results
                display_barrel_results(result)
                
                # Download options
                st.subheader("📥 Download Results")
                col1, col2 = st.columns(2)
                
                with col1:
                    # JSON download
                    json_data = result.to_json()
                    st.download_button(
                        label="📄 Download JSON",
                        data=json_data,
                        file_name=f"{uploaded_file.name}_extraction.json",
                        mime="application/json"
                    )
                
                with col2:
                    # CSV download
                    csv_data = create_csv_export(result)
                    st.download_button(
                        label="📊 Download CSV",
                        data=csv_data,
                        file_name=f"{uploaded_file.name}_extraction.csv",
                        mime="text/csv"
                    )
                
                # Summary report
                with st.expander("📋 View Summary Report"):
                    report = create_summary_report(result)
                    st.text(report)
                    
                    st.download_button(
                        label="📋 Download Report",
                        data=report,
                        file_name=f"{uploaded_file.name}_report.txt",
                        mime="text/plain"
                    )
                
            except (PDFValidationError, AWSClientError, Exception) as e:
                # Use centralized error handling
                error_handler.display_error(e, "PDF extraction")
    
    else:
        st.info("👆 Please upload a PDF file to begin extraction")
        
        # Help section
        with st.expander("ℹ️ How to use this tool"):
            st.markdown("""
            **Step 1:** Upload a PDF engineering drawing (max 100MB)
            
            **Step 2:** Choose your extraction method:
            - **Auto**: Tries the best available method automatically
            - **Claude 4 Sonnet**: Advanced AI vision analysis
            - **Textract**: AWS document text extraction
            - **Bedrock Data Automation**: Structured data extraction
            
            **Step 3:** Click "Extract Data" to process your drawing
            
            **Step 4:** Review results and download in your preferred format
            
            **Supported Content:**
            - Dimensional measurements (linear, angular, radial, diameter)
            - Tolerance specifications (±, geometric tolerances)
            - Part numbers and identifiers
            - Text annotations and notes
            """)


if __name__ == "__main__":
    main()
